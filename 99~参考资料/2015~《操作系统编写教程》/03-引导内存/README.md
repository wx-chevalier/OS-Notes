*开始之前你可能需要 Google 了解的概念： memory offsets, pointers*

**目的： 理解计算机内存是如何组织的**

请重点学习下 [这个文档] (
http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf)<sup>1</sup>
的 14 页上的内存分布图。

这个章节的主要目的是要明白，启动引导扇区的程序被储存在内存的哪个位置

我可以直接告诉你， BIOS 会把引导程序放置在内存地址 `0x7C00` 处，然后把系统控制权交给这里的程序。要理解这一点，你最好是自己尝试一下别的位置。

下面我们打印一个 X 字符在屏幕上。我们使用 4 种不同方式来看看哪些可以打印，哪些没有打印，并思考为什么会出现不同的结果。

**打开文件 `boot_sect_memory.asm`**

首先，我们定义了 X 是纯数据（一般编译程序会把纯数据放在单独的数据段），并用个标号来标记 X 的位置，代码如下：
```nasm
the_secret:
    db "X"
```

然后我们试着用不同的方式来访问  `the_secret` ：

1. `mov al, the_secret`
2. `mov al, [the_secret]`
3. `mov al, the_secret + 0x7C00`
4. `mov al, 2d + 0x7C00`, 这里 `2d` 是 'X' 字节在二进制数据中的绝对地址。

现在分析一下代码，同时也有注意阅读里面的注释。

编译并运行我们的代码。你可能会看到类似 `1[2¢3X4X` 的字符串，这里 1 和 2 后面的数据是随机的内存数据 。

如果你添加或者删除了一些指令，那么一定要记得重新计算 X 的偏移地址。然后用新的偏移地址代替代码中的 `0x2d` 。

请不要继续学习下一阶段的课程，除非你已经百分百理解了偏移地址和内存编址。


全局偏移地址
-----------------

对引导程序来说，偏移地址 `0x7c00` 是会经常用到的，但是总是使用硬编码地址是非常不方便的。所以现代汇编器都提供了一个定义全局偏移地址的命令 `org` ：

```nasm
[org 0x7c00]
```

下面 **打开 `boot_sect_memory_org.asm`** 你能够看到在引导程序中标准的打印数据方法，也就是方法 2。编译和运行这份代码，你就可以理解 `org` 指令是如何影响我们前面的方案。

仔细阅读代码中的注释理解 `org` 是如何影响我们的输出结果的。

-----

[1] 这篇教程很大程度上都是受该文档的启发。请阅读根目录下的 README ，里面对此有详细的描述。
